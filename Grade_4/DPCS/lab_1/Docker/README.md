### task 1
Використовували команду docker `run -d -p 8080:80 docker/welcome-to-docker` щоб перевірити працесдатність докеру.
![](report/task_1_1.png)
![](report/task_1_2.png)
![](report/task_1_3.png)
Перейшли до слідкуванням роботи контейнеру
![](report/task_1_4.png)
### task 2
Після клону репозітория getting-started-todo-app запускаємо докер композ, який хранить у собі декілька сервесів
![](report/task_2_1.png)
![](report/task_2_2.png)
Змінемо файл `backend/src/routes/getGreeting.js` щоб рандомно виводити 1 з 3х фраз які запмиані у масиві.
![](report/task_2_3.png)
Також файл `client/src/components/AddNewItemForm.jsx` щоб рандомно виводити 1 з 3х фраз які запмиані у масиві.
![](report/task_2_4.png)
Та файл `client/src/index.scss`
![](report/task_2_5.png)
Після перезаватаження сторінки усі зміни спрацювали
![](report/task_2_6.png)
### task 3
Ствоюємо на докерхабі свой власний репозіторій
![](report/task_3_1.png)
Собираємо вже існуючий проект в докері, використовуя команду `docker build -t bukhtahub/getting-started-todo-app .` та перевіряємо чи створився образ у докері
![](report/task_3_2.png)
![](report/task_3_3.png)
Закидуємо образ до докерхабу та перевіряємо
![](report/task_3_4.png)
### task 4
Запускаємо докер контейнер через десктопний додаток під назвою **welcome-to-docker** та з портом 8080
![](report/task_4_1.png)
Щоб зупинити контейнер та закрити порт, натискаємо кнопку stop
![](report/task_4_2.png)
### task 5
Робимо пошук образу **welcome-to-docker** та бачимо подробний вивод результату пошуку
![](report/task_5_1.png)
Пуллемо докер образ та получаємо подробну інфомрацію о статусі.
![](report/task_5_2.png)
за допомогою команди docker image ls ми можемо передивитись усі встановлені образи
![](report/task_5_3.png)
Також подивимося історію образа, що ми щойно встановили. На виході бачимо всі шари, їхні розміри та команду, яку було використано для створення шару.
![](report/task_5_4.png)
### task 6
Створюємо репозіторій на докерхабі
![](report/task_6_1.png)
Сконили проект з гіта та створюємо образ
![](report/task_6_2.png)
після перевяряємо образ, запускаємо його на порту 8080 та робимо таг. Після цього намагаємося його закинути на репу.
![](report/task_6_3.png)
Після релогіну, пуш пройшов успішно
![](report/task_6_4.png)
![](report/task_6_5.png)
### task 7
Білдемо та запускаємо докер композ. Бачимо що він успішно запустився. Далі закриваємо сессію
![](report/task_7_1.png)
![](report/task_7_2.png)
### task 8
Запускаємо базовий контейнер и віртуальний терминал від убунту. Оновлюємо пакети.
![](report/task_8_1.png)
Встановлюємо ноджс та перевіряємо.
![](report/task_8_2.png)
Далі у новому терміналі комітім текущі зміни у новому слою **node-base**. Перевіряємо історію та праціздатність. 
![](report/task_8_3.png)
Після видаляємо базовий образ
![](report/task_8_4.png)
### task 9
Скачали app.zip з документації докера та разпаковуємо. Створюємо **Dockerfile**, стврорюємо директорію з проектом
![](report/task_9_1.png)
Белдемо проект. Пройшло успішно.Так як ми не дали назву образу, перевіремо увесь список та запустимо його по ID
![](report/task_9_2.png)
![](report/task_9_3.png)
Створюємо таг для вже зібраного імеджу за допомогою ``docker image tag``
![](report/task_9_4.png)
### task 10
Зайдемо у попередньо склоновону та спробуємо ще раз збілдити. Як ми бачимо, докер узяв уже опрацьовані степи к кеша.
![](report/task_10_1.png)
Змінемо порядок степов у докерфайлі. Створемо **.dockerignore** файл та перебілдемо проект. Деякі степи досі 
![](report/task_10_2.png)беруться з кешу.
![](report/task_10_3.png)
### task 11
Генеруємо Spring проект https://start.spring.io/ та создамо докерфайл
![](report/task_11_1.png)
Білдемо успішно
![](report/task_11_2.png)
Запускаємо контейнер за допомогою ``docker run -d -p 8080:8080 spring-helloworld`` та перевіряємо результат через 
![](report/task_11_3.png)локалхост 8080
Тепер попробуємо мульті-шагову зборку
![](report/task_11_4.png)
Перший етап залишається таким самим, як і попередній Docker-файл, надаючи середовище Java Development Kit (JDK) для побудови програми. Цей етап називається builder. 
Другий етап - це новий етап, який називається final. На ньому використовується стрункіший образ **eclipse-temurin:21.0.2_13-jre-jammy**, який містить лише середовище виконання Java (JRE), необхідне для запуску програми. Цей образ містить середовище виконання Java (JRE), якого достатньо для запуску скомпільованої програми (JAR-файл).
Під час збірки, можемо побачити збірку кожного стейджа. Під кінець у нас є два образа, один з яких тримає у собі мінімум для працездатності контейнера.
![](report/task_11_5.png)
![](report/task_11_6.png)
### task 12:
Створемо докер композ щоб автоматично запускати сервиси на специфічному порті
![](report/task_12_1.png)
![](report/task_12_2.png)